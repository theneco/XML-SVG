import xml.etree.ElementTree as ET
import argparse
import sys
import os

def convert_xml_to_svg(xml_file, svg_file):
    """
    Parses an XML cut file and converts its contents into an SVG file.

    This script reads <cut-list> properties for the overall dimensions,
    draws <reg-mark> elements as 3x3mm black squares, and converts
    <cut-path> elements, including points and splines, into SVG paths.

    Args:
        xml_file (str): The path to the input XML file.
        svg_file (str): The path for the output SVG file.
    """
    try:
        # Parse the XML file
        tree = ET.parse(xml_file)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Error: Could not parse XML file. Please ensure it's well-formed. Details: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print(f"Error: Input file not found at '{xml_file}'", file=sys.stderr)
        sys.exit(1)

    # The units are in hundredths of a millimeter, so we need to scale down by 100
    if root.get('units') != 'hundredths_mm':
        print(f"Warning: XML units are not 'hundredths_mm'. The script will proceed, but output may be incorrectly scaled.", file=sys.stderr)

    scale_factor = 0.01

    # Get the overall width and height for the SVG canvas
    try:
        width_px = float(root.get('width')) * scale_factor
        height_px = float(root.get('height')) * scale_factor
    except (TypeError, ValueError):
        print("Error: Could not read 'width' or 'height' attributes from the XML root.", file=sys.stderr)
        sys.exit(1)

    # Start building the SVG content
    # The viewBox defines the coordinate system, and width/height define the output size.
    svg_elements = [
        f'<svg width="{width_px}mm" height="{height_px}mm" viewBox="0 0 {width_px} {height_px}" xmlns="http://www.w3.org/2000/svg">',
        '<!-- Generated by XML to SVG Converter -->',
        f'<rect x="0" y="0" width="{width_px}" height="{height_px}" fill="white" stroke="gray" stroke-width="0.5"/>' # Optional background
    ]

    # Process registration marks (reg-marks)
    reg_mark_size_mm = 3.0
    for mark in root.findall('reg-mark'):
        try:
            # The XML coordinates are assumed to be the center of the mark
            center_x = float(mark.get('x')) * scale_factor
            center_y = float(mark.get('y')) * scale_factor

            # To draw a rect from the top-left, we offset by half the size
            top_left_x = center_x - (reg_mark_size_mm / 2)
            top_left_y = center_y - (reg_mark_size_mm / 2)

            svg_elements.append(
                f'<rect x="{top_left_x:.4f}" y="{top_left_y:.4f}" width="{reg_mark_size_mm}" height="{reg_mark_size_mm}" fill="black"/>'
            )
        except (TypeError, ValueError):
            print(f"Warning: Skipping a registration mark with invalid coordinates.", file=sys.stderr)

    # Process each cut path
    for i, path in enumerate(root.findall('cut-path')):
        path_data = []
        is_first = True

        for element in path:
            try:
                if element.tag == 'point':
                    x = float(element.get('x')) * scale_factor
                    y = float(element.get('y')) * scale_factor

                    # 'M' moves the pen to the starting point. 'L' draws a line to the next point.
                    command = "M" if is_first else "L"
                    path_data.append(f"{command} {x:.4f} {y:.4f}")
                    is_first = False

                elif element.tag == 'spline':
                    # A 'spline' in this XML corresponds to a cubic Bezier curve in SVG
                    # Command 'C' uses three points: two control points and the end point.
                    x1 = float(element.get('x1')) * scale_factor
                    y1 = float(element.get('y1')) * scale_factor
                    x2 = float(element.get('x2')) * scale_factor
                    y2 = float(element.get('y2')) * scale_factor
                    x3 = float(element.get('x3')) * scale_factor
                    y3 = float(element.get('y3')) * scale_factor

                    path_data.append(f"C {x1:.4f} {y1:.4f}, {x2:.4f} {y2:.4f}, {x3:.4f} {y3:.4f}")
            except (TypeError, ValueError):
                print(f"Warning: Skipping an element in path {i+1} due to invalid coordinates.", file=sys.stderr)

        if path_data:
            # 'Z' closes the path to form a complete shape
            path_data.append("Z")
            path_string = " ".join(path_data)
            # Define path style: no fill, red stroke for visibility
            svg_elements.append(f'<path d="{path_string}" fill="none" stroke="red" stroke-width="0.1mm"/>')

    svg_elements.append('</svg>')

    # Write the collected SVG elements to the output file
    try:
        with open(svg_file, 'w') as f:
            f.write('\n'.join(svg_elements))
        print(f"Successfully converted '{xml_file}' to '{svg_file}'")
    except IOError as e:
        print(f"Error: Could not write to output file '{svg_file}'. Details: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    """
    Main function to set up command-line argument parsing and run the conversion.
    """
    parser = argparse.ArgumentParser(
        description="Convert an XML cut file to an SVG file, preserving all dimensions and locations.",
        epilog="Example: python xml_to_svg_converter.py my_cut_file.xml -o my_drawing.svg"
    )
    parser.add_argument(
        "input_xml",
        help="The path to the source XML file."
    )
    parser.add_argument(
        "-o", "--output_svg",
        help="The path for the destination SVG file. If not provided, the output will be saved next to the input file with a .svg extension."
    )

    args = parser.parse_args()

    input_file = args.input_xml
    output_file = args.output_svg

    # If no output file is specified, create one based on the input filename
    if not output_file:
        base_name, _ = os.path.splitext(input_file)
        output_file = base_name + '.svg'

    convert_xml_to_svg(input_file, output_file)

if __name__ == '__main__':
    main()